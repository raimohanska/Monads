<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Monads by @raimohanska</title>

		<meta name="description" content="Monads for Dummies">
		<meta name="author" content="Juha Paananen">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">
    <style>
      .reveal pre.left,.reveal pre.right {
        width: 45%;
        float: left;
        margin: 2%;
      }
      .notransform { text-transform: none !important; }
    </style>

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
<section>
<h1>Monads</h1>
<h3>Not Burritos</h3>
<p>
<small>Created by <a href="http://github.com/raimohanska">Juha Paananen</a> / <a href="http://twitter.com/raimohanska">@raimohanska</a></small>
</p>
  <aside class="notes" data-markdown>
- Mystified, simple
- hope you feel that way to after this
- first intro to why monads, then intro to haskell (I don't assume you all know it), typeclasses, functors and monads
- we'll do short time-boxed exercises (in haskell) between my preachings.
- cool if you have your ghc. there's a web alternative though
- finally there will be more free coding and time for questions etc
- about me: software consultant and coder from Reaktor. long Java background, FP enthusiast since 2008 or so, used haskell in small projects since 2010 or so. very much into FRP, created reactive-bacon for Haskell, then Bacon.js for javascript. not a Haskell guru, morelike a fanboy
  </aside>
</section>

<section><h2>Monads are like...</h2>
  <aside class="notes" data-markdown>

- burritos : not unless burritos too are monoids in the category of endofunctors
- "are just a .." won't do justice. they can be seen as "programmable semicolon", "execution context", "container".. but those are just different aspects of monads
- monads are simple

  </aside>
</section>

<section> <h2 style="text-transform:none;">m a -> (a -> m b) -> m b</h2> </section>

<section><h3>How do you learn to code?</h3></section>

<section><h3>How do you learn monads?</h3></section>

<section>
<img style="width: 80%;" src="img/batman-monads.png">
</section>

<section><h1>Motivation</h1></section>

<section>
<h3>Monad as Execution Context</h3>
<h2 class="fragment">Haskell IO</h2>
  <aside class="notes" data-markdown>

- If side-effects, runs in IO monad
- Input, Output, Mutable state
- Compiler knows if you don't have side-effects
- Caching etc
- Everything that has side-effects is an IO action
  </aside>
</section>
<section>
<h4>Monad as Execution Context</h4>
<h2>IO actions</h2>
<h4 class="notransform fragment">getTweets :: IO [Tweet]</h4>
<h4 class="notransform fragment">retweet :: [Tweet] -> IO ()</h4>
</section>

<section>
<h4>Monad as Execution Context</h4>
<h2 class="notransform"><small>getTweets</small> >>= <small>retweet</small></h2>
</section>

<section>
<h2>>>=</h2>
<h4>The programmable semicolon</h4>
</section>

<section>
<h2>>>=</h2>
<h4>Maybe - composes optional values</h4>
</section>

<section>
<h2>>>=</h2>
<h4>List - transforms lists</h4>
</section>

<section>
<h2>>>=</h2>
<h4>STM - composes transactional operations</h4>
</section>

<section>
<h2>>>=</h2>
<h4>Snap - access to request/response</h4>
</section>

<section>
<h2>>>=</h2>
<h4>Continuation - composes callbacks</h4>
</section>

<section>
<h2>Do-notation</h2>
<pre><code data-trim contenteditable>
do
  tweets <- getTweets
  let reversed = map reverse tweets
  retweet reversed
</code></pre>
</section>

<section>
<h1>Haskell</h1>
<aside class="notes" data-markdown>
- Functional language
- Simple, powerful type system
- Lazy evaluation
</aside>
</section>

<section> <h2 style="text-transform:none;">What are they?</h2> </section>

<section> <h2 style="text-transform:none;">Chainable</h2> </section>

<section> <h2 style="text-transform:none;">Chainable Operation</h2> </section>

<section>
<h2>Async Operation</h2>
<h3>In Haskell</h3>
<pre><code data-trim contenteditable>
module Async where

type Callback a = (a -> IO()) 

data Async a = Async { run :: (Callback a -> IO ()) }
</code></pre>
<p>Task that calls your callback with result value</p>
</section>

<section>
<h2>Async example</h2>
<pre class="left"><code data-trim contenteditable>
example = Async $Â \callback -> 
  callback "Hello world"
</code></pre>
<pre class="right"><code data-trim contenteditable>
function example(callback) {
  callback("Hello world")
}
</code></pre>
</section>

<section>
<h2>Retweet all!</h2>
<pre><code data-trim contenteditable>
retweetAll =
  users = fetchUsers
  tweets = map fetchTweets users
  forEach tweets retweet
</code></pre>
</section>

<section>
<h2>Retweet all!</h2>
<p>The borken way</p>
<pre><code data-trim contenteditable>
function retweetAll(callback) {
  fetchUsers(function(users) {
    users.forEach(function(user) {
      fetchTweets(user, function(tweets) {
        tweets.forEach(function(tweet) {
          retweet(tweet, callback)
        })
      })
    })
  })
}
</code></pre>
</section>

<section>
<h2>Retweet all!</h2>
<p>With Bacon.js</p>
<pre><code data-trim contenteditable>
fetchUsers                   // Stream [User]
  .flatMap(Bacon.fromArray)  // Stream User
  .flatMap(fetchTweets)      // Stream [Tweet]
  .flatMap(Bacon.fromArray)  // Stream Tweet
  .onValue(retweet)
</code></pre>
</section>

<section>
<h2>Retweet all!</h2>
<p>With Monads</p>
<pre><code data-trim contenteditable>
retweetAll = do
  users <- fetchUsers
  tweets <- mapM fetchTweets users
  mapM retweet (join tweets)
</code></pre>
</section>

<section><h2>How?</h2></section>

<section>
<section><h2>You Are Here</h2>
<pre><code data-trim contenteditable>
module Async where

type Callback a = (a -> IO()) 

data Async a = Async { run :: (Callback a -> IO ()) }
</code></pre>
</section>
<section>
<h2>You want to be here</h2>
<pre><code data-trim contenteditable>
retweetAll = do
  users <- fetchUsers
  tweets <- (mapM fetchTweets users)
  mapM_ retweet (join tweets)
</code></pre>
</section>
</section>

<section><h2>It still isn't a Monad</h2></section>

<section><h2>Monad <i>instance</i> for Async</h2></section>

<section><h2>Typeclasses</h2></section>

<section>
<section>
<h2>Typeclasses</h2>
<p>The Show class</p>
<pre><code data-trim contenteditable>
class Show a where
  show :: a -> String

print :: Show a => a -> IO ()
</code></pre>
</section>
<section>
<h2>Typeclasses</h2>
<p>A Simple data type</p>
<pre><code data-trim contenteditable>
data Book = Book { name :: String }
</code></pre>
</section>
<section>
<h2>Typeclasses</h2>
<p>Show Instance</p>
<pre><code data-trim contenteditable>
data Book = Book { name :: String }

instance Show Book where
  show = name
</code></pre>
</section>
</section>


<section>
<section>
<h2>Typeclasses</h2>
<p>Type Parameters</p>
<pre><code data-trim contenteditable>
data Maybe a = Nothing | Just a
</code></pre>
</section>
<section>
<h2>Typeclasses</h2>
<p>Type Parameters, Functor</p>
<pre><code data-trim contenteditable>
class Functor f where
  fmap :: (a -> b) -> f a -> f b

data Maybe a = Nothing | Just a
</code></pre>
</section>
<section>
<h2>Typeclasses</h2>
<p>Functor for Maybe</p>
<pre><code data-trim contenteditable>
class Functor f where
  fmap :: (a -> b) -> f a -> f b

data Maybe a = Nothing | Just a

instance Functor Maybe where
  fmap fun Nothing = Nothing
  fmap fun (Just x) = Just (fun x)
</code></pre>
</section>
</section>

<section>
<section>
<h2>Typeclasses</h2>
<p>Monad typeclass</p>
<pre><code data-trim contenteditable>
class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  return :: a -> m a
</code></pre>
</section>
<section>
<h2>Typeclasses</h2>
<p>A simple List type</p>
<pre><code data-trim contenteditable>
data List a = Nil | Cons a (List a)
</code></pre>
</section>
<section>
<h2>Typeclasses</h2>
<p>A simple List type</p>
<pre><code data-trim contenteditable>
data List a = Nil | Cons a (List a)

map :: (a -> b) -> List a -> List b
flatMap :: List a -> (a -> List b) -> List b
</code></pre>
</section>
<section>
<h2>Typeclasses</h2>
<p>Monad for List</p>
<pre><code data-trim contenteditable>
data List a = Nil | Cons a (List a)

instance Monad List where
   (>>=) = flatMap
   return x = Cons x Nil
</code></pre>
</section>
</section>
<section> <h2 style="text-transform:none;">M a -> (a -> M b) -> M b</h2> </section>
<section>
<section>
<h2>Async Monad</h2>
<h3>Recap</h3>
<pre><code data-trim contenteditable>
data Async a = Async { run :: (Callback a -> IO ()) }
</code></pre>
</section>
<section>
<h2>Async Monad</h2>
<h3>bind signature</h3>
<pre><code data-trim contenteditable>
data Async a = Async { run :: (Callback a -> IO ()) }

bind :: Async a -> (a -> Async b) -> Async b
</code></pre>
</section>
<section>
<h2>Async Monad</h2>
<h3>bind signature</h3>
<pre><code data-trim contenteditable>
data Async a = Async { run :: (Callback a -> IO ()) }

bind :: Async a -> (a -> Async b) -> Async b

1. Executes first task
2. Uses result to create new task
3. Executes the new task
</code></pre>

</section>
<section>
<h2>Async Monad</h2>
<p>in action</p>
<pre><code data-trim contenteditable>
retweetAll = do
  users <- fetchUsers
  tweets <- mapM fetchTweets users
  mapM retweet (join tweets)
</code></pre>
</section>
</section>

<section><h1>Magic?</h2></section>
<section>
<section><h1>Desugaring!</h2></section>
<section>
<h2>Desugaring</h2>
<h3>Haskell compiler desugars this</h3>
<pre><code data-trim contenteditable>
retweetAll = do
  users <- fetchUsers
  tweets <- (mapM fetchTweets users)
  mapM_ retweet (join tweets)
</code></pre>
</section>
<section>
<h2>Desugaring</h2>
<h3>... into this</h3>
<pre><code data-trim contenteditable>
retweetAll = fetchUsers >>= 
  (\users -> mapM fetchTweets users) >>= 
  (\tweets -> mapM_ retweet (join tweets))
</code></pre>
</section>
</section>

<section>
<h1>Your turn</h1>
<p><a href="https://github.com/raimohanska/monads/assignments/haskell">github.com/raimohanska/monads/assignments/haskell</a></p>
</section>

<section>
<h1>That's it!</h1>
<p>Juha Paananen (@raimohanska)</p>
<p><a href="https://github.com/raimohanska/monads">github.com/raimohanska/monads</a></p>
</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
